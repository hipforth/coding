## easy

1. **两数之和**
    解法：哈希表，将当前num[i]和target-num[i]一同放入哈希表，复杂的O(nlogn)
2. **有效的括号**
    一个左括号对应一个右括号
    建立一个哈希表，存储所有左右对应的括号，然后双指针，第一个和最后一个对比。
3. **最大子序和**
    动态规划，条件为比较前面求和与num[i]的大小，然后比较历史最大值与当前值。
    转移方程：$f(i) = max(f(i-1)+nums[i], nums[i])$
4. **爬楼梯**
    很简单，两种状态f(n)=f(n-1)+f(n-2)，计算每一次的值存储起来，O(n)复杂度
5. **对称二叉树**
    构建一个helper函数，传入左右孩子，之后判断左右都为空，左右值相等，再继续递归调用左右孩子。
6. **二叉树的最大深度**
    从当前节点递归的调用自己，返回左右孩子深度的最大值+1即是当前节点的最大值。
7. **买卖股票的最佳时机**
    用一个变量来记录历史最低价格，如果有比它还低的则更新历史最低，每次计算与历史最低的差价和历史利润比较取最大值
8. **只出现一次的数字**
    通过异或的交换律，对数组内所有数字进行异或，结果就是只出现一次的数字。
    如果其他数字不是偶数个，那就只能建立哈希表，然后按照尺寸排序，第一位的就是。
9. **最小栈：保存当前栈的最小元素**
    构造一个辅助栈来做这个事情
10. **相交链表**
    两个链表，走到尾节点然后从另一个的头结点开始，这样两个会同时到达相交的节点。
11. **多数元素：大于n/2**
    直接进行排序，位于n/2下标一定是最大元素。
12. **反转链表**
    三指针迭代来做这个事
13. **翻转二叉树**
    从底层开始，一步一步往上反转
14. **回文链表**
    首先快慢指针找到中点和尾巴，然后把后半截全放到栈中。再出栈比较，如果要找到最长回文链表，就只能放入数组中。
15. **移动零:**将数组中的零移至末尾并不改变其他元素的相对顺序
    双指针，一个指针遍历数组，另一个指向非零元素。如果第一个指针遇到非零就把当前值赋给第二个指针，这样第一个指针结束前面都是非零，只需在第二个指针后面补零即可。
16. **比特位计数**
    进行奇偶判断来动态规划，奇数一定是比前面那个偶数在最低位多一个1，偶数的1等于自己除以2的数的1的个数。
    则动态规划：若当前为为奇数，则1的个数为前一个偶数加一。若当前为偶数，则1的个数为自身除以2以后的1的个数。初始零为最初的偶数，有零个1.
17. **找到所有数组中消失的数字**
    简单来想就是先全部加入哈希表然后遍历。
18. **汉明距离**
    汉明距离指两个数字对应二进制位不同的位的数目。
    这个直接先异或(相同为0不同为1)，然后求结果中1的个数，参考比特位计数



## Medium
1. **两数相加**：给定两个链表表示两个非负整数，数字按照逆序存储
    很简单啊为啥是medium，直接进位加，然后如果一个空了直接把另一个接在后面就行
2. **无重复字符的最长子串**
    依次递增的枚举子串的起始位置，然后从这个起始位置开始枚举，构建一个哈希表来确定窗口的大小(最暴力的方法)。
    时间上进行简化，采用滑动窗口：
    1. 窗口左边界不动，移动窗口右边界直到遇到重复。
    2. 此时移动窗口左边界，然后继续移动右边界直到遇到重复字符，继续循环直到右边界到结尾。
    3. 过程中保留每一个左边界对应的右边界，输出最长的。
3. **最长回文子串**
    双指针，枚举每一个都为中间值，然后向两边开始扩散。
    1. 记录start和end为枚举当前字符的两个边界值，如果下一次枚举长度超过则更新边界值。
    2. 因为枚举时分奇数和偶数，所以构建一个辅助函数，假设当前字符为奇数的中心(i,i)，假设为偶数(i,i+1)
4. **盛水最多的容器**
    双指针：左右指针能容纳的接水最大值为min(left, right)*(right-left+1)
    可见，容纳水的量是由最小指针决定的，所以一开始两指针分别指向左右两端，然后移动小指针。
    1. 两指针指向左右两端，移动小指针，更新接水最大值。
    2. 如果两个指针大小相同则任意移动(可以移动左指针)
    3. 直到两指针重合。返回历史最大接水值。
5. **三数之和**：判断a+b+c=0是否存在abc
    暴力法：枚举每一个数，按照两数之和的方法，复杂度O(n^2logn)
    排序+双指针：首先排好序，第一个若大于零那么肯定不存在。主要思想是：排序后左指针指向较小值，右指针指向较大值，然后遍历num[i]作为中间值，对于每一个num[i]，如果小于零则移动左指针，大于零则移动右指针。等于零则首先移动num[i]直到不等于零(去除重复解),然后以当前num[i]继续移动左右指针。
6. **删除链表的倒数第N个节点**
    这个题这么简单是怎么成为Medium的？
7. **下一个排列**
    很简单，从后往前，找到第一个a[i] < a[i+1]的数对然后交换，但是对于a[i+1]后的数还得进行一次升序排序。(但是因为他们本来是降序的，所以直接翻转就好)
8. **搜索旋转排序数组**
    二分法，从中间分开，其中一个一定有序，另一个未知，有序部分用二分查找；无序部分继续二分，一个一定有序另一个不一定，继续循环。
9. **在排序数组中查找元素的第一个和最后一个值**
    二分查找，找到数的最小下标为左界，最大为右界
10. **全排列**
    返回一个不重复数组的全排列:这种只能是回溯法
11. **组合综合**:
    回溯法
12. **旋转图像**
    先上下翻转，再按照对角线交换。
13. **跳跃游戏**
    枚举数组中的零开头到零为结尾的子数组(第一个为零结尾), 判断子数组最大跳跃值能否越过零(即是零左边第一个要大于一，左边第二个要大于二，依次直到左边界)。
    //或者可以直接跳，每次从
14. **合并区间**
    对所有区间的左端点进行升序排序(如果相同则按照右端点升序排序)，得到一个左端点升序的区间
    1. 以第一个区间为合并区间，枚举后续当前区间，如果当前区间左端点大于合并右端点，则重新开始当前区间为新的合并区间
    2. 如果当前左端点位于合并区间内，则俩区间最大右端点为合并右端点，合并左端点保持不变，继续枚举下一个区间
    [0,1] [0,2] [0,3] [1,9] [2,5] [10,11] [12,20] [19,20]
15. **机器人不同路径**:从左上角移动到右下角
    经典动态规划，f(i,j)表示到达(i,j)的路径，所以f(i,j) = f(i-1,j) + f(i,j-1) 只能从上方或者左方走过来
    边界条件：
    1. i-1 < 0 和 j-1 < 0如果出现则需要忽略
    2. 初始条件为f(0,0) = 1, 即f(0,n) = f(0,n-1) = f(0,n-2) = ... = f(0,0) = 1;同理 f(m,0) = 1; 提前赋值就无需考虑边界条件了。
16. **最小路径和**:给定一个grid, 找出从左上角到右下角的路径使得路径上数字和最小。
    动态规划转移方程为: f(i,j) = min(f(i-1,j), f(i,j-1)), f(i,j)为左上角到达(i,j)处路径上最小数字和。
    边界条件: 当处于上边界，即i=0, 上一个路径只能从左边来f(i,j) = f(i,j-1)；同理当j=0；
17. **颜色分类**:用012分别表示红白蓝，一个n元素数组，原地进行排序，相同颜色相邻按照红白蓝顺序排列
    暴力法：统计012各自在数组中数目，然后重新给数组写入数。
    双指针法：一个指针指向头，一个指针指向尾，枚举num[i],将0与头部指针交换数字，将2与尾部指针交换数字；
    1. 若0与头部交换的数字是1，则继续枚举num[i+1]，若与头部指针交换出来的是0或2，继续枚举num[i];
    2. 同理，num[i]是2与尾部交换，交换出来的是1则枚举num[i+1]，交换出来的是0或2则枚举num[i];
    3. 以上左右指针会继续往前走，回退的只是[i]
18. **子集**：一个整数数组num,元素不重复，返回该数组所有子集
    应该是回溯法吧。。
19. **单词搜索**:给定一个二维grid，内部存储一个一个字符，给出一个字符串，查找二维格子中是否能够组成该字符串(需要按照水平相邻或垂直相邻来组成)。
    先遍历搜索首尾单词，获得m个首尾单词组，然后按照求路径的方法，
    还是回溯法。。。
20. **不同的二叉搜索树**：给一个整数n,求恰由n个节点组成且节点值从1到n互不相同的二叉搜索树的种类数。
    二叉搜索树：左节点小于根节点，右节点大于根节点。
    求解：动态规划
    1. 枚举数组中每一个数为头结点，左边的为左孩子，右边的为右孩子
    2. 同理，左孩子中也枚举每一个为左孩子的头结点，右孩子也枚举每一个为右孩子的头结点
    3. 如此循环
    可以看出通过枚举数组中每一个为头结点，问题可以分为两个同类型的子问题，且头结点 = 左节点 + 右节点，因此我们只需求出每个头结点然后求和即可。
    1. 定义F(i,n)表示以i为根，长度为n的不同二叉搜索树的个数
    2. 放弃了，太难了，后面再说吧
21. **验证二叉搜索树**
    递归调用自己的子节点，设定一个作用域，在作用域内则继续递归
22. **二叉树的层序遍历**
    使用一个二元组来表示节点和其所在的层序<node, level>，递归的调用，详参二叉树文件夹
23. **最长连续序列**：给定一个未排序的数组num，找出数字连续的最长序列(不要求序列元素在原数组中连续)的长度，在时间复杂度O(n)内完成。
    按照顺序枚举每一个数，从当前数为起点往后，开始查询x+1,..., x+y是否存在(这里查询可以用哈希来做);
    1. 在枚举的时候，首先确定x-1不存在，排除重复查找
    2. 如果x-1存在，继续枚举下一个，x-1不存在则开始查找x+y，更新最长序列长度;
24. **环形链表II**:给定环形链表，返回开始入环的第一个节点
    暴力解法:用哈希表来存储每一个节点，直到出现重复即是入口节点。
    双指针法：快慢指针第一次相遇位于环内，
25. **排序链表**：给定头结点，按照升序排序链表
    二分法，将链表一分为二，分别对两个进行排序，然后采用合并两个有序链表进行归并。
    1. 递归终止条件：链表的节点个数小于或等于1，即当链表为空或链表只包含1个节点时。
    2. 对于前半部节点，传入的是当前头结点和中间节点，对于后半部节点，传入的是中间节点和当前尾节点。
    3. 递归终止条件：当前头结点为空，或头结点与尾节点相邻。
    4. 调用 `return merg(sortList(head, mid), sortList(mid, tail));`
26. **乘积最大子数组**：给定num，求其中乘积最大的连续子数组，返回子数组的乘积
    动态规划：转移方程根据正负性进行讨论
$$
f_{max}(i) = {max}_{i=1}^n (f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i)
$$

$$
f_{min}(i) = {min}_{i=1}^n (f_{max}(i-1)*a_i, f_{min}(i-1)*a_i,a_i )
$$
27. **打家劫舍**:不能偷相邻房屋
    动态规划：如果只有一间，则只能偷这个；如果有两间，则选取金额大的偷；
    如果大于两间，设f(k)为第k能偷到的最高金额
    1. 对于第k个房屋，偷第K就不能偷第K-1间，此时总金额f[k] = f[k-2] + num[k]
    2. 不偷第k间，此时f[k] = f[k-1]
    则最大f[k]应在两个中取最大值即f[k] = max(f[k-2]+num[k], f[k-1])
    f[0] = num[0]
    f[1] = max(num[0], num[1])    
28. **岛屿数量**：类似于求连通域数量
    递归的方式深度有限搜索，参考深度优先搜索文件夹
29. **最大正方形**
    在一个0和1组成的二维矩阵中找到只包含1的最大正方形，返回其面积
    动态规划的方法：略难，先放过
30. **寻找重复数**
    先排序然后按位异或
31. **和为K的子数组**
    滑动窗口：如果窗口内值小于K，就移动右边界。如果大于K就移动左边界。
    如果等于K则只移动左边界。
32. **最短无序子数组**

33. **回文子串**

34. **合并K个排序链表**
    






