## easy
1. **判断字符是否唯一**
    定义一个包含26个字符a-z的bool数组，然后遍历如果出现就给bool数组赋为true
2. **合并排序后的数组**：给定排序后的数组A，B，A的末端有足够的缓冲空间容纳B，合并AB并排序
    双指针法：将两个数组看作队列，每次从两个数字头部去除比较小的数字放到结果中。
    1. 正向双指针
        1. 设置两个指针pa和pb作为队列的头部指针，两个都超出尺寸才结束循环
        2. 若pa超出A的尺寸则将pb接到尾部，若pb超出尺寸则将pa接到尾部
        3. 都没超出尾部就判断哪个小就将其接到尾部。
    2. 逆向指针法：正向指针需要临时变量，而A中已有足够的空间。
        1. pa指向m-1(A数组实际尺寸为m+n)，pb指向n-1    
        2. 比较pa和pa谁大就将其放到A数组的末尾
        3. 循环条件是pa,pb都超出头部小于零
        4. 若pa超出头部，则将pb放入A数组的头部，若pb超出头部，则将pa放入头部
3. **字符串压缩**
    简单的方法是将字母放入一个栈，数字放入一个栈
    1. 首先将第一个字母放入栈中，同时数字栈放第一个数字1
    2. 继续枚举字符串，如果当前字符和字符栈顶部相同，则当前数字栈顶部+1
    3. 如果和字符栈顶部不同，则当前字符压入字符栈，数字栈压入数字1
    4. 然后依次出栈，先出数字栈后出字符栈(从尾部开始放入)
4. **主要元素**: 数字中占比超过一半的元素称为主要元素
    很简单，直接排序，位于n/2一定是主要元素，先排序后判断复杂度O(nlogn)
    如何判断:长度是否大于n/2
5. **返回倒数第K个节点**
    这不很简单吗，直接双指针，，，，
6. **汉诺塔问题**

7. **移除重复节点**：移除未排序链表的重复节点
    简单来想：哈希表+删除链表节点
8. **判断是否为字符重排**
    直接哈希存储S1，然后查询S2
    或者更简单，直接ASII码排序然后判断是否S1=S2即可
9. **栈的最小值**
    做过了，另开一个栈来保存，这样读取时间就为1
10. **回文排列**
    若奇数长度，则应有一个字符是单数，其他的都是双数。
    若偶数长度，则字符应全是双数。
11. **三步问题**
    简单动态规划
12. **字符串轮转**:给定两个字符串判断S2是否由S1旋转而成
    拼接两个S2，则S1一定包含在其中
    利用滑动窗口来判断，窗口长度为S1尺寸
    S.assign(S2.begin(), S2.end());
13. **不用ifelse来判断两个数的最大值**
    1. 数学方法
    $Max(a,b) = \frac{\vert a-b\vert + a+b}{2}$
    2. 移位+处理溢出
    计算机中算数右移，高补符号位，所以int类型右移31位会得到符号位
14. **按摩师**
    这不是打家劫舍吗？？？
    动态规划转移方程
15. **连续数列**
    动态规划最大子序和
16. **消失的数字**：数组中包含0-n所有整数，中间缺失了一个
    求和然后和数列和相减，如果数字不是唯一的呢？
    只能哈希先判断然后求和。
17. **翻转数位**
    找到所有的零，中心扩散找到最大滑窗。
18. **回文链表**
    快慢指针找到中间，将后半段放入栈中，然后一一出栈对比
19. **检查平衡性**：任一节点其两颗子树的深度不超过1
    暴力法就是进行遍历节点然后求当前节点的最大深度与左节点比较，这里遍历采用后序遍历
    从底向上，计算出每一个节点的最大深度
    $height(p) = 0$；p是空节点
    $height(p) = max(height(p.left), height(p.right))$
20. **汉明距离**
    两数中不同位的个数
    1. 先异或，异或的结果中有几个1即不同位的个数
    2. 判断异或结果中有几个1
        1. 可以先构建一个哈希表，利用奇数比前一个偶数多一个1，偶数的1的个数和偶数/2的个数相同的性质，求出所有的数1的个数，构建哈希表。
        2. 利用m&(m-1)能够消除m的最后一位1，消除完成m=0来判定当前m中有几个1
21. **不用加减乘除实现四则运算**


## medium
1. **环路检测**：返回有环链表的头结点
    暴力法：用哈希存储节点来判断
2. **节点间通路**
    有向图，无向图算法
3. **栈排序**：对栈进行升序排序
    要排序的栈设为s, 辅助栈为temp，对s的顶部元素cur，分为两种情况
    1. 若cur <= temp.front(), 将cur压入temp中
    2. 若cur > temp.front(), 将temp栈顶弹出，逐一压入s中，知道cur <= temp.front()，再将cur压入temp中
    简单来讲，是先将s的栈顶元素拿出，然后将其压入

```cpp
void SortStack(std::Stack<int>& s)
{
    std::Stack<int> temp;
    while(!s.empty())
    {
        int curr = s.top();
        s.pop();
        while(!temp.empty() && curr > temp.top())
        {
            s.push(temp.top());
            temp.pop();
        }
        temp.push(curr);
    }
    while(!temp.empty())
    {
        s.push(temp.top());
        temp.pop();
    }
}
```
4. **开根**
    1. 二分法
    2. 牛顿迭代法

5. 

    


